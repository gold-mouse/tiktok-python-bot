"""
This type stub file was generated by pyright.
"""

from typing import Iterable, Union, overload

@overload
def always_bytes(str_or_bytes: None, *encode_args) -> None:
    ...

@overload
def always_bytes(str_or_bytes: Union[str, bytes], *encode_args) -> bytes:
    ...

def always_bytes(str_or_bytes: Union[None, str, bytes], *encode_args) -> Union[None, bytes]:
    ...

@overload
def always_str(str_or_bytes: None, *encode_args) -> None:
    ...

@overload
def always_str(str_or_bytes: Union[str, bytes], *encode_args) -> str:
    ...

def always_str(str_or_bytes: Union[None, str, bytes], *decode_args) -> Union[None, str]:
    """
    Returns,
        str_or_bytes unmodified, if
    """
    ...

_control_char_trans = ...
_control_char_trans_newline = ...
_control_char_trans = ...
_control_char_trans_newline = ...
def escape_control_characters(text: str, keep_spacing=...) -> str:
    """
    Replace all unicode C1 control characters from the given text with a single "."

    Args:
        keep_spacing: If True, tabs and newlines will not be replaced.
    """
    ...

def bytes_to_escaped_str(data, keep_spacing=..., escape_single_quotes=...): # -> str:
    """
    Take bytes and return a safe string that can be displayed to the user.

    Single quotes are always escaped, double quotes are never escaped:
        "'" + bytes_to_escaped_str(...) + "'"
    gives a valid Python string.

    Args:
        keep_spacing: If True, tabs and newlines will not be escaped.
    """
    ...

def escaped_str_to_bytes(data): # -> str:
    """
    Take an escaped string and return the unescaped bytes equivalent.

    Raises:
        ValueError, if the escape sequence is invalid.
    """
    ...

def is_mostly_bin(s: bytes) -> bool:
    ...

def is_xml(s: bytes) -> bool:
    ...

def clean_hanging_newline(t):
    """
        Many editors will silently add a newline to the final line of a
        document (I'm looking at you, Vim). This function fixes this common
        problem at the risk of removing a hanging newline in the rare cases
        where the user actually intends it.
    """
    ...

def hexdump(s): # -> Generator[tuple[str, str, str], Any, None]:
    """
        Returns:
            A generator of (offset, hex, str) tuples
    """
    ...

NO_ESCAPE = ...
MULTILINE_CONTENT = ...
SINGLELINE_CONTENT = ...
MULTILINE_CONTENT_LINE_CONTINUATION = ...
def split_special_areas(data: str, area_delimiter: Iterable[str]): # -> list[str | Any]:
    """
    Split a string of code into a [code, special area, code, special area, ..., code] list.

    For example,

    >>> split_special_areas(
    >>>     "test /* don't modify me */ foo",
    >>>     [r"/\\*[\\s\\S]*?\\*/"])  # (regex matching comments)
    ["test ", "/* don't modify me */", " foo"]

    "".join(split_special_areas(x, ...)) == x always holds true.
    """
    ...

def escape_special_areas(data: str, area_delimiter: Iterable[str], control_characters): # -> str:
    """
    Escape all control characters present in special areas with UTF8 symbols
    in the private use plane (U+E000 t+ ord(char)).
    This is useful so that one can then use regex replacements on the resulting string without
    interfering with special areas.

    control_characters must be 0 < ord(x) < 256.

    Example:

    >>> print(x)
    if (true) { console.log('{}'); }
    >>> x = escape_special_areas(x, "{", ["'" + SINGLELINE_CONTENT + "'"])
    >>> print(x)
    if (true) { console.log('ï¿½}'); }
    >>> x = re.sub(r"\\s*{\\s*", " {\n    ", x)
    >>> x = unescape_special_areas(x)
    >>> print(x)
    if (true) {
        console.log('{}'); }
    """
    ...

def unescape_special_areas(data: str): # -> str:
    """
    Invert escape_special_areas.

    x == unescape_special_areas(escape_special_areas(x)) always holds true.
    """
    ...

